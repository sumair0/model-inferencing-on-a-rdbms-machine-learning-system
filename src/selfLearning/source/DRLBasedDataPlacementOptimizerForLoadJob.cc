#ifndef DRL_BASED_DATA_PLACEMENT_OPTIMIZER_FOR_LOAD_JOB_CC
#define DRL_BASED_DATA_PLACEMENT_OPTIMIZER_FOR_LOAD_JOB_CC

#include "DRLBasedDataPlacementOptimizerForLoadJob.h"

namespace pdb {


//Constructor
DRLBasedDataPlacementOptimizerForLoadJob :: DRLBasedDataPlacementOptimizerForLoadJob(int numTotalPartitions, int numNodes, std::string loadJobName, std::string dataType, SelfLearningWrapperServer& server, std::shared_ptr<RLClient> rlClientPtr) {
    this->numPartitions = numTotalPartitions;
    this->state.numTotalPartitions = numTotalPartitions;
    this->state.numNodes = numNodes;
    this->producerJobName = loadJobName;
    this->dataType = dataType;
    this->server = server;
    this->rlClientPtr = rlClientPtr;
    this->computeLastReward(this->reward);
    std::cout << "reward=" << this->reward << std::endl;
    double variance;
    this->estimateSizeOfDataToLoad(this->state.inputSize, variance);
    this->populateLambdaCandidates(this->lambdaCandidates, this->state);
    this->state.print();
}


//Now we implement a Deep Reinforcement Learning-based optimizer
Handle<LambdaIdentifier> DRLBasedDataPlacementOptimizerForLoadJob :: getBestLambda() {

     std::string errMsg;
     this->bestLambdaIndex = this->rlClientPtr->getBestLambdaIndex(this->state,
                        this->reward, errMsg);
     std::cout << "bestLambdaIndex = " << bestLambdaIndex << std::endl;
     std::cout << "lambdaCandidates.size() = " << lambdaCandidates.size() << std::endl;
     if (bestLambdaIndex < this->lambdaCandidates.size()) {

          return this->lambdaCandidates[bestLambdaIndex];

      } else {
          std::cout << "we didn't find any lambda probably because it is first time execution" << std::endl;
          return nullptr;
      }

}

//to get the best page size based on data size and selected lambda (particularly if selected is non-partitioning)
size_t DRLBasedDataPlacementOptimizerForLoadJob :: getBestPageSize() {

     if ((numPartitions < 1) || (this->state.numNodes < 1)) {
         return 0;
     }
     if ((bestLambdaIndex >= 0) && (bestLambdaIndex < this->lambdaCandidates.size())) {

         return this->state.inputSize / this->numPartitions;

     } else { 

         return this->state.inputSize / (this->numPartitions/this->state.numNodes);

     }
}

size_t DRLBasedDataPlacementOptimizerForLoadJob :: getEstimatedSize() {
    return this->state.inputSize;
}

//to return the last reward
double DRLBasedDataPlacementOptimizerForLoadJob :: getLastReward() {

     return this->reward;

}


//to get all candidate lambdas and for each lambda, we compute its:

// (1) distance to current dataset
// ---- if one candidate is the direct consumer of the data to generate, data distance is 0
// ---- if one candidate is the consumer of a direct consumer, distance is 1, and so on
// ---- if one candidate is not any consumer of the data directly or indirectly, data distance is -1
// ---- if one candidate has more than two distances, we set data distance to be the smallest positive one

// (2) minimum distance to join operations
// ---- if the lambda is directly applied in a shuffle operation such as Join selection (in a stage with repartition sink), the shuffle distance is 0
// ---- otherwise, the distance is set to the number of transformations needs to be applied to the lambda's output to be served in a shuffle operation.
// ---- if the lambda has nothing to do with shuffle operations, we set the shuffle distance to -1.


// (3) minimum distance to aggregation operations
// ---- if the lambda is directly applied in a shuffle operation such as Aggregation key projection (in a stage with shuffle sink), the shuffle distance is 0
// ---- otherwise, the distance is set to the number of transformations needs to be applied to the lambda's output to be served in a shuffle operation.
// ---- if the lambda has nothing to do with shuffle operations, we set the shuffle distance to -1.

// (4) frequency of the lambda
// ---- if the lambda appears in one consumer stage as the partition lambda or part of the partition lambda, we add 1 to the count.

// (5) selectivity of the lambda
// ---- in history, the ratio of the output size of the computation stage that contains the output lambda to the size of the data to be generated.
// ---- if one candidate has more than two selectivities, we set it to be the smallest positive one.

// (6) key distribution
// --- number of unique keys generated by hashing the output of this lambda.




bool DRLBasedDataPlacementOptimizerForLoadJob :: populateLambdaCandidates(std::vector<Handle<LambdaIdentifier>> & lambdaCandidates, RLState & state) {
     std::cout << "to get lambda candidates for " << this->producerJobName << std::endl;
     return server.getAllLambdaCandidates(this->producerJobName, this->dataType, lambdaCandidates, state);
     
}


//to return the estimated size of data to load
bool DRLBasedDataPlacementOptimizerForLoadJob :: estimateSizeOfDataToLoad(double & avgSize, double & variance) {
 
     return server.getInfoForLoadJob (this->producerJobName, avgSize, variance);

}

//to return the reward for applying last RL-selected lambda
bool DRLBasedDataPlacementOptimizerForLoadJob :: computeLastReward(double & reward) {
    std::cout << "to compute last reward for " << this->producerJobName << std::endl;
    return server.getReward(this->producerJobName, reward);

}



}


#endif
