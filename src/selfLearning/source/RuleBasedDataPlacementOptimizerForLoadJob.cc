#ifndef RULE_BASED_DATA_PLACEMENT_OPTIMIZER_FOR_LOAD_JOB_CC
#define RULE_BASED_DATA_PLACEMENT_OPTIMIZER_FOR_LOAD_JOB_CC

#include "RuleBasedDataPlacementOptimizerForLoadJob.h"

namespace pdb {


//Constructor
RuleBasedDataPlacementOptimizerForLoadJob :: RuleBasedDataPlacementOptimizerForLoadJob(int numTotalPartitions, std::string loadJobName, std::string dataType, SelfLearningWrapperServer& server) {
    this->numPartitions = numTotalPartitions;
    this->producerJobName = loadJobName;
    this->loadJobInfo.setLoadJobName ( loadJobName );
    this->dataType = dataType;
    this->server = server;
    server.getProducerConsumerInfoForLoadJob( loadJobName, loadJobInfo, consumers );
}


//Now we implement a simple rule-based optimizer, assuming there is only 1 consumer job stage
Handle<LambdaIdentifier> RuleBasedDataPlacementOptimizerForLoadJob :: getBestLambda() {
    if (consumers.size() == 0) {
       return nullptr;
    }
    Handle<LambdaIdentifier> partitionLambda = nullptr;
    std::cout << " there are " << consumers.size() << " pairs" << std::endl;
    //first to get the consumer job stages
    for (auto it = consumers.begin(); it != consumers.end(); ++it) {
        std::cout << "get into the loop" << std::endl;
        //for the 1st consumer job stage, apply following rules:
        std::shared_ptr<JobStageSelfLearningInfo> consumerInfo = it->second;
        //Rule 1: if the consumer job stage has a Repartition sink, we use the lambda associated with this job stage;
        //Rule 2: if the consumer job stage has a Shuffle sink, we use the lambda associated with this job stage;
        std::cout << "SinkType is " << consumerInfo->getSinkType() << std::endl;
        if ((consumerInfo->getSinkType() == "Shuffle")||(consumerInfo->getSinkType() == "Repartition")) {
             std::cout << "to get lambda for jobId = " << consumerInfo->getJobId() << ", targetComputation = " 
                      << consumerInfo->getTargetComputationName() << ", dataType = " << dataType << std::endl;
             partitionLambda = server.getLambda(consumerInfo->getJobId(), consumerInfo->getTargetComputationName(), 
                      dataType, consumerInfo->getIndexInInputs());
        } else if (consumerInfo->getSinkType() == "UserSet") {
        //Rule 3: if the direct consumer job stage has a UserSet sink, and the consumer job stage of the UserSet generated by the direct consumer job stage has a Repartition or Shuffle sink, we use the lambda associated with the indirect consumer job stage;
             //1. to get the identifiter to the output set of the direct consumer job stage
             long dataId = server.getSinkDataId(consumerInfo->getJobStageId());             
             std::string indirectDataType = server.getDataType(dataId);
             std::cout << "indirectDataType is " << indirectDataType << std::endl;
             //2. to get the consumers that consume the output set
             std::unordered_map<std::pair<long, long>, std::shared_ptr<JobStageSelfLearningInfo>, PairKeyHash, PairKeyEqual> indirectConsumers;
             std::cout << "to get consumers for data" << std::endl;
             server.getConsumerInfoForData(dataId, indirectConsumers);
             //3. follow rule-1 and rule-2
             for (auto it1 = indirectConsumers.begin(); it1 != indirectConsumers.end(); ++it1) {
                 std::shared_ptr<JobStageSelfLearningInfo> indirectConsumerInfo = it1->second;
                 std::string sinkType = indirectConsumerInfo->getSinkType();
                 std::cout << "SinkType is " << sinkType << std::endl;
                 if ((sinkType == "Shuffle") || (sinkType == "Repartition")) {
                     std::cout << "to get lambda for jobId = " << indirectConsumerInfo->getJobId()
                        << ", targetComputation = " << indirectConsumerInfo->getTargetComputationName()
                        << ", dataType = " << indirectDataType << std::endl;
                     partitionLambda = server.getLambda(indirectConsumerInfo->getJobId(), 
                        indirectConsumerInfo->getTargetComputationName(), indirectDataType,
                        indirectConsumerInfo->getIndexInInputs());
                 } 
                 if (partitionLambda->getLambdaName().find("native") != std::string::npos) {
                     std::cout << "INFO: continue, because we can't support partitioning using native lambda: " 
                       << partitionLambda->getLambdaName() << std::endl;
                    continue;
                 }
                 if (partitionLambda != nullptr) {
                     break;
                 }
             }

        }
        if (partitionLambda != nullptr) {
            break;
        }
        
    }
    return partitionLambda;
}

size_t RuleBasedDataPlacementOptimizerForLoadJob :: getBestPageSize() {

     //first to estimate the output dataset size
     size_t outputSize = this->loadJobInfo.getAvgSize();
     if (numPartitions < 1) {
         return 0;
     }
     //Rule 1: set page size, so that the output dataset can distribute to all thread
     //That is #PageSize = #DataSetSize / (#numThreads * #numNodes) 
     return outputSize/numPartitions;

}

size_t RuleBasedDataPlacementOptimizerForLoadJob :: getEstimatedSize() {

    size_t outputSize = this->loadJobInfo.getAvgSize();
    std::cout << "####################Estimated outputSize is " << outputSize << "######################" << std::endl;    return outputSize;

}

}


#endif
